{"remainingRequest":"C:\\Users\\18117\\Desktop\\M2\\M2BIGDATA\\djangoYueProjectDviz\\big-screen-vue-datav-master\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\18117\\Desktop\\M2\\M2BIGDATA\\djangoYueProjectDviz\\big-screen-vue-datav-master\\node_modules\\cache-loader\\dist\\cjs.js??ref--1-0!C:\\Users\\18117\\Desktop\\M2\\M2BIGDATA\\djangoYueProjectDviz\\big-screen-vue-datav-master\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!C:\\Users\\18117\\Desktop\\M2\\M2BIGDATA\\djangoYueProjectDviz\\big-screen-vue-datav-master\\node_modules\\@jiaminghi\\data-view\\lib\\components\\waterLevelPond\\src\\main.vue?vue&type=script&lang=js","dependencies":[{"path":"C:\\Users\\18117\\Desktop\\M2\\M2BIGDATA\\djangoYueProjectDviz\\big-screen-vue-datav-master\\node_modules\\@jiaminghi\\data-view\\lib\\components\\waterLevelPond\\src\\main.vue","mtime":1703850131685},{"path":"C:\\Users\\18117\\Desktop\\M2\\M2BIGDATA\\djangoYueProjectDviz\\big-screen-vue-datav-master\\babel.config.js","mtime":1691760298000},{"path":"C:\\Users\\18117\\Desktop\\M2\\M2BIGDATA\\djangoYueProjectDviz\\big-screen-vue-datav-master\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1703850126584},{"path":"C:\\Users\\18117\\Desktop\\M2\\M2BIGDATA\\djangoYueProjectDviz\\big-screen-vue-datav-master\\node_modules\\babel-loader\\lib\\index.js","mtime":1703850127068},{"path":"C:\\Users\\18117\\Desktop\\M2\\M2BIGDATA\\djangoYueProjectDviz\\big-screen-vue-datav-master\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1703850126584},{"path":"C:\\Users\\18117\\Desktop\\M2\\M2BIGDATA\\djangoYueProjectDviz\\big-screen-vue-datav-master\\node_modules\\vue-loader\\lib\\index.js","mtime":1703850110565}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9yZWdlbmVyYXRvclJ1bnRpbWUgZnJvbSAiQzovVXNlcnMvMTgxMTcvRGVza3RvcC9NMi9NMkJJR0RBVEEvZGphbmdvWXVlUHJvamVjdER2aXovYmlnLXNjcmVlbi12dWUtZGF0YXYtbWFzdGVyL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9yZWdlbmVyYXRvclJ1bnRpbWUuanMiOwppbXBvcnQgX2FzeW5jVG9HZW5lcmF0b3IgZnJvbSAiQzovVXNlcnMvMTgxMTcvRGVza3RvcC9NMi9NMkJJR0RBVEEvZGphbmdvWXVlUHJvamVjdER2aXovYmlnLXNjcmVlbi12dWUtZGF0YXYtbWFzdGVyL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3luY1RvR2VuZXJhdG9yLmpzIjsKaW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gIkM6L1VzZXJzLzE4MTE3L0Rlc2t0b3AvTTIvTTJCSUdEQVRBL2RqYW5nb1l1ZVByb2plY3REdml6L2JpZy1zY3JlZW4tdnVlLWRhdGF2LW1hc3Rlci9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheS5qcyI7CmltcG9ydCBfdG9Db25zdW1hYmxlQXJyYXkgZnJvbSAiQzovVXNlcnMvMTgxMTcvRGVza3RvcC9NMi9NMkJJR0RBVEEvZGphbmdvWXVlUHJvamVjdER2aXovYmlnLXNjcmVlbi12dWUtZGF0YXYtbWFzdGVyL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90b0NvbnN1bWFibGVBcnJheS5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnJlcGxhY2UuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5maWxsLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2UuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5mb3ItZWFjaC5qcyI7CmltcG9ydCB7IHV1aWQgfSBmcm9tICcuLi8uLi8uLi91dGlsL2luZGV4JzsKaW1wb3J0IHsgZGVlcE1lcmdlIH0gZnJvbSAnQGppYW1pbmdoaS9jaGFydHMvbGliL3V0aWwvaW5kZXgnOwppbXBvcnQgeyBkZWVwQ2xvbmUgfSBmcm9tICdAamlhbWluZ2hpL2MtcmVuZGVyL2xpYi9wbHVnaW4vdXRpbCc7CmltcG9ydCBDUmVuZGVyIGZyb20gJ0BqaWFtaW5naGkvYy1yZW5kZXInOwpleHBvcnQgZGVmYXVsdCB7CiAgbmFtZTogJ0R2V2F0ZXJMZXZlbFBvbmQnLAogIHByb3BzOiB7CiAgICBjb25maWc6IE9iamVjdCwKICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkgewogICAgICByZXR1cm4ge307CiAgICB9CiAgfSwKICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkgewogICAgdmFyIGlkID0gdXVpZCgpOwogICAgcmV0dXJuIHsKICAgICAgZ3JhZGllbnRJZDogIndhdGVyLWxldmVsLXBvbmQtIi5jb25jYXQoaWQpLAogICAgICBkZWZhdWx0Q29uZmlnOiB7CiAgICAgICAgLyoqCiAgICAgICAgICogQGRlc2NyaXB0aW9uIERhdGEKICAgICAgICAgKiBAdHlwZSB7QXJyYXk8TnVtYmVyPn0KICAgICAgICAgKiBAZGVmYXVsdCBkYXRhID0gW10KICAgICAgICAgKiBAZXhhbXBsZSBkYXRhID0gWzYwLCA0MF0KICAgICAgICAgKi8KICAgICAgICBkYXRhOiBbXSwKICAgICAgICAvKioKICAgICAgICAgKiBAZGVzY3JpcHRpb24gU2hhcGUgb2Ygd2FudGVyIGxldmVsIHBvbmQKICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfQogICAgICAgICAqIEBkZWZhdWx0IHNoYXBlID0gJ3JlY3QnCiAgICAgICAgICogQGV4YW1wbGUgc2hhcGUgPSAncmVjdCcgfCAncm91bmRSZWN0JyB8ICdyb3VuZCcKICAgICAgICAgKi8KICAgICAgICBzaGFwZTogJ3JlY3QnLAogICAgICAgIC8qKgogICAgICAgICAqIEBkZXNjcmlwdGlvbiBXYXRlciB3YXZlIG51bWJlcgogICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9CiAgICAgICAgICogQGRlZmF1bHQgd2F2ZU51bSA9IDMKICAgICAgICAgKi8KICAgICAgICB3YXZlTnVtOiAzLAogICAgICAgIC8qKgogICAgICAgICAqIEBkZXNjcmlwdGlvbiBXYXRlciB3YXZlIGhlaWdodCAocHgpCiAgICAgICAgICogQHR5cGUge051bWJlcn0KICAgICAgICAgKiBAZGVmYXVsdCB3YXZlSGVpZ2h0ID0gNDAKICAgICAgICAgKi8KICAgICAgICB3YXZlSGVpZ2h0OiA0MCwKICAgICAgICAvKioKICAgICAgICAgKiBAZGVzY3JpcHRpb24gV2F2ZSBvcGFjaXR5CiAgICAgICAgICogQHR5cGUge051bWJlcn0KICAgICAgICAgKiBAZGVmYXVsdCB3YXZlT3BhY2l0eSA9IDAuNAogICAgICAgICAqLwogICAgICAgIHdhdmVPcGFjaXR5OiAwLjQsCiAgICAgICAgLyoqCiAgICAgICAgICogQGRlc2NyaXB0aW9uIENvbG9ycyAoaGV4fHJnYnxyZ2JhfGNvbG9yIGtleXdvcmRzKQogICAgICAgICAqIEB0eXBlIHtBcnJheTxTdHJpbmc+fQogICAgICAgICAqIEBkZWZhdWx0IGNvbG9ycyA9IFsnIzAwQkFGRicsICcjM0RFN0M5J10KICAgICAgICAgKiBAZXhhbXBsZSBjb2xvcnMgPSBbJyMwMDAnLCAncmdiKDAsIDAsIDApJywgJ3JnYmEoMCwgMCwgMCwgMSknLCAncmVkJ10KICAgICAgICAgKi8KICAgICAgICBjb2xvcnM6IFsnIzNERTdDOScsICcjMDBCQUZGJ10sCiAgICAgICAgLyoqCiAgICAgICAgICogQGRlc2NyaXB0aW9uIEZvcm1hdHRlcgogICAgICAgICAqIEB0eXBlIHtTdHJpbmd9CiAgICAgICAgICogQGRlZmF1bHQgZm9ybWF0dGVyID0gJ3t2YWx1ZX0lJwogICAgICAgICAqLwogICAgICAgIGZvcm1hdHRlcjogJ3t2YWx1ZX0lJwogICAgICB9LAogICAgICBtZXJnZWRDb25maWc6IHt9LAogICAgICByZW5kZXJlcjogbnVsbCwKICAgICAgc3ZnQm9yZGVyR3JhZGllbnQ6IFtdLAogICAgICBkZXRhaWxzOiAnJywKICAgICAgd2F2ZXM6IFtdLAogICAgICBhbmltYXRpb246IGZhbHNlCiAgICB9OwogIH0sCiAgY29tcHV0ZWQ6IHsKICAgIHJhZGl1czogZnVuY3Rpb24gcmFkaXVzKCkgewogICAgICB2YXIgc2hhcGUgPSB0aGlzLm1lcmdlZENvbmZpZy5zaGFwZTsKICAgICAgaWYgKHNoYXBlID09PSAncm91bmQnKSByZXR1cm4gJzUwJSc7CiAgICAgIGlmIChzaGFwZSA9PT0gJ3JlY3QnKSByZXR1cm4gJzAnOwogICAgICBpZiAoc2hhcGUgPT09ICdyb3VuZFJlY3QnKSByZXR1cm4gJzEwcHgnOwogICAgICByZXR1cm4gJzAnOwogICAgfSwKICAgIHNoYXBlOiBmdW5jdGlvbiBzaGFwZSgpIHsKICAgICAgdmFyIHNoYXBlID0gdGhpcy5tZXJnZWRDb25maWcuc2hhcGU7CiAgICAgIGlmICghc2hhcGUpIHJldHVybiAncmVjdCc7CiAgICAgIHJldHVybiBzaGFwZTsKICAgIH0KICB9LAogIHdhdGNoOiB7CiAgICBjb25maWc6IGZ1bmN0aW9uIGNvbmZpZygpIHsKICAgICAgdmFyIGNhbGNEYXRhID0gdGhpcy5jYWxjRGF0YSwKICAgICAgICByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7CiAgICAgIHJlbmRlcmVyLmRlbEFsbEdyYXBoKCk7CiAgICAgIHRoaXMud2F2ZXMgPSBbXTsKICAgICAgc2V0VGltZW91dChjYWxjRGF0YSwgMCk7CiAgICB9CiAgfSwKICBtZXRob2RzOiB7CiAgICBpbml0OiBmdW5jdGlvbiBpbml0KCkgewogICAgICB2YXIgaW5pdFJlbmRlciA9IHRoaXMuaW5pdFJlbmRlciwKICAgICAgICBjb25maWcgPSB0aGlzLmNvbmZpZywKICAgICAgICBjYWxjRGF0YSA9IHRoaXMuY2FsY0RhdGE7CiAgICAgIGluaXRSZW5kZXIoKTsKICAgICAgaWYgKCFjb25maWcpIHJldHVybjsKICAgICAgY2FsY0RhdGEoKTsKICAgIH0sCiAgICBpbml0UmVuZGVyOiBmdW5jdGlvbiBpbml0UmVuZGVyKCkgewogICAgICB2YXIgJHJlZnMgPSB0aGlzLiRyZWZzOwogICAgICB0aGlzLnJlbmRlcmVyID0gbmV3IENSZW5kZXIoJHJlZnNbJ3dhdGVyLXBvbmQtbGV2ZWwnXSk7CiAgICB9LAogICAgY2FsY0RhdGE6IGZ1bmN0aW9uIGNhbGNEYXRhKCkgewogICAgICB2YXIgbWVyZ2VDb25maWcgPSB0aGlzLm1lcmdlQ29uZmlnLAogICAgICAgIGNhbGNTdmdCb3JkZXJHcmFkaWVudCA9IHRoaXMuY2FsY1N2Z0JvcmRlckdyYWRpZW50LAogICAgICAgIGNhbGNEZXRhaWxzID0gdGhpcy5jYWxjRGV0YWlsczsKICAgICAgbWVyZ2VDb25maWcoKTsKICAgICAgY2FsY1N2Z0JvcmRlckdyYWRpZW50KCk7CiAgICAgIGNhbGNEZXRhaWxzKCk7CiAgICAgIHZhciBhZGRXYXZlID0gdGhpcy5hZGRXYXZlLAogICAgICAgIGFuaW1hdGlvbldhdmUgPSB0aGlzLmFuaW1hdGlvbldhdmU7CiAgICAgIGFkZFdhdmUoKTsKICAgICAgYW5pbWF0aW9uV2F2ZSgpOwogICAgfSwKICAgIG1lcmdlQ29uZmlnOiBmdW5jdGlvbiBtZXJnZUNvbmZpZygpIHsKICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnLAogICAgICAgIGRlZmF1bHRDb25maWcgPSB0aGlzLmRlZmF1bHRDb25maWc7CiAgICAgIHRoaXMubWVyZ2VkQ29uZmlnID0gZGVlcE1lcmdlKGRlZXBDbG9uZShkZWZhdWx0Q29uZmlnLCB0cnVlKSwgY29uZmlnKTsKICAgIH0sCiAgICBjYWxjU3ZnQm9yZGVyR3JhZGllbnQ6IGZ1bmN0aW9uIGNhbGNTdmdCb3JkZXJHcmFkaWVudCgpIHsKICAgICAgdmFyIGNvbG9ycyA9IHRoaXMubWVyZ2VkQ29uZmlnLmNvbG9yczsKICAgICAgdmFyIGNvbG9yTnVtID0gY29sb3JzLmxlbmd0aDsKICAgICAgdmFyIGNvbG9yT2Zmc2V0R2FwID0gMTAwIC8gKGNvbG9yTnVtIC0gMSk7CiAgICAgIHRoaXMuc3ZnQm9yZGVyR3JhZGllbnQgPSBjb2xvcnMubWFwKGZ1bmN0aW9uIChjLCBpKSB7CiAgICAgICAgcmV0dXJuIFtjb2xvck9mZnNldEdhcCAqIGksIGNdOwogICAgICB9KTsKICAgIH0sCiAgICBjYWxjRGV0YWlsczogZnVuY3Rpb24gY2FsY0RldGFpbHMoKSB7CiAgICAgIHZhciBfdGhpcyRtZXJnZWRDb25maWcgPSB0aGlzLm1lcmdlZENvbmZpZywKICAgICAgICBkYXRhID0gX3RoaXMkbWVyZ2VkQ29uZmlnLmRhdGEsCiAgICAgICAgZm9ybWF0dGVyID0gX3RoaXMkbWVyZ2VkQ29uZmlnLmZvcm1hdHRlcjsKICAgICAgaWYgKCFkYXRhLmxlbmd0aCkgewogICAgICAgIHRoaXMuZGV0YWlscyA9ICcnOwogICAgICAgIHJldHVybjsKICAgICAgfQogICAgICB2YXIgbWF4VmFsdWUgPSBNYXRoLm1heC5hcHBseShNYXRoLCBfdG9Db25zdW1hYmxlQXJyYXkoZGF0YSkpOwogICAgICB0aGlzLmRldGFpbHMgPSBmb3JtYXR0ZXIucmVwbGFjZSgne3ZhbHVlfScsIG1heFZhbHVlKTsKICAgIH0sCiAgICBhZGRXYXZlOiBmdW5jdGlvbiBhZGRXYXZlKCkgewogICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyLAogICAgICAgIGdldFdhdmVTaGFwZXMgPSB0aGlzLmdldFdhdmVTaGFwZXMsCiAgICAgICAgZ2V0V2F2ZVN0eWxlID0gdGhpcy5nZXRXYXZlU3R5bGUsCiAgICAgICAgZHJhd2VkID0gdGhpcy5kcmF3ZWQ7CiAgICAgIHZhciBzaGFwZXMgPSBnZXRXYXZlU2hhcGVzKCk7CiAgICAgIHZhciBzdHlsZSA9IGdldFdhdmVTdHlsZSgpOwogICAgICB0aGlzLndhdmVzID0gc2hhcGVzLm1hcChmdW5jdGlvbiAoc2hhcGUpIHsKICAgICAgICByZXR1cm4gcmVuZGVyZXIuYWRkKHsKICAgICAgICAgIG5hbWU6ICdzbW9vdGhsaW5lJywKICAgICAgICAgIGFuaW1hdGlvbkZyYW1lOiAzMDAsCiAgICAgICAgICBzaGFwZTogc2hhcGUsCiAgICAgICAgICBzdHlsZTogc3R5bGUsCiAgICAgICAgICBkcmF3ZWQ6IGRyYXdlZAogICAgICAgIH0pOwogICAgICB9KTsKICAgIH0sCiAgICBnZXRXYXZlU2hhcGVzOiBmdW5jdGlvbiBnZXRXYXZlU2hhcGVzKCkgewogICAgICB2YXIgbWVyZ2VkQ29uZmlnID0gdGhpcy5tZXJnZWRDb25maWcsCiAgICAgICAgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyLAogICAgICAgIG1lcmdlT2Zmc2V0ID0gdGhpcy5tZXJnZU9mZnNldDsKICAgICAgdmFyIHdhdmVOdW0gPSBtZXJnZWRDb25maWcud2F2ZU51bSwKICAgICAgICB3YXZlSGVpZ2h0ID0gbWVyZ2VkQ29uZmlnLndhdmVIZWlnaHQsCiAgICAgICAgZGF0YSA9IG1lcmdlZENvbmZpZy5kYXRhOwogICAgICB2YXIgX3JlbmRlcmVyJGFyZWEgPSBfc2xpY2VkVG9BcnJheShyZW5kZXJlci5hcmVhLCAyKSwKICAgICAgICB3ID0gX3JlbmRlcmVyJGFyZWFbMF0sCiAgICAgICAgaCA9IF9yZW5kZXJlciRhcmVhWzFdOwogICAgICB2YXIgcG9pbnRzTnVtID0gd2F2ZU51bSAqIDQgKyA0OwogICAgICB2YXIgcG9pbnRYR2FwID0gdyAvIHdhdmVOdW0gLyAyOwogICAgICByZXR1cm4gZGF0YS5tYXAoZnVuY3Rpb24gKHYpIHsKICAgICAgICB2YXIgcG9pbnRzID0gbmV3IEFycmF5KHBvaW50c051bSkuZmlsbCgwKS5tYXAoZnVuY3Rpb24gKGZvbywgaikgewogICAgICAgICAgdmFyIHggPSB3IC0gcG9pbnRYR2FwICogajsKICAgICAgICAgIHZhciBzdGFydFkgPSAoMSAtIHYgLyAxMDApICogaDsKICAgICAgICAgIHZhciB5ID0gaiAlIDIgPT09IDAgPyBzdGFydFkgOiBzdGFydFkgLSB3YXZlSGVpZ2h0OwogICAgICAgICAgcmV0dXJuIFt4LCB5XTsKICAgICAgICB9KTsKICAgICAgICBwb2ludHMgPSBwb2ludHMubWFwKGZ1bmN0aW9uIChwKSB7CiAgICAgICAgICByZXR1cm4gbWVyZ2VPZmZzZXQocCwgW3BvaW50WEdhcCAqIDIsIDBdKTsKICAgICAgICB9KTsKICAgICAgICByZXR1cm4gewogICAgICAgICAgcG9pbnRzOiBwb2ludHMKICAgICAgICB9OwogICAgICB9KTsKICAgIH0sCiAgICBtZXJnZU9mZnNldDogZnVuY3Rpb24gbWVyZ2VPZmZzZXQoX3JlZiwgX3JlZjIpIHsKICAgICAgdmFyIF9yZWYzID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksCiAgICAgICAgeCA9IF9yZWYzWzBdLAogICAgICAgIHkgPSBfcmVmM1sxXTsKICAgICAgdmFyIF9yZWY0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjIsIDIpLAogICAgICAgIG94ID0gX3JlZjRbMF0sCiAgICAgICAgb3kgPSBfcmVmNFsxXTsKICAgICAgcmV0dXJuIFt4ICsgb3gsIHkgKyBveV07CiAgICB9LAogICAgZ2V0V2F2ZVN0eWxlOiBmdW5jdGlvbiBnZXRXYXZlU3R5bGUoKSB7CiAgICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXIsCiAgICAgICAgbWVyZ2VkQ29uZmlnID0gdGhpcy5tZXJnZWRDb25maWc7CiAgICAgIHZhciBoID0gcmVuZGVyZXIuYXJlYVsxXTsKICAgICAgcmV0dXJuIHsKICAgICAgICBncmFkaWVudENvbG9yOiBtZXJnZWRDb25maWcuY29sb3JzLAogICAgICAgIGdyYWRpZW50VHlwZTogJ2xpbmVhcicsCiAgICAgICAgZ3JhZGllbnRQYXJhbXM6IFswLCAwLCAwLCBoXSwKICAgICAgICBncmFkaWVudFdpdGg6ICdmaWxsJywKICAgICAgICBvcGFjaXR5OiBtZXJnZWRDb25maWcud2F2ZU9wYWNpdHksCiAgICAgICAgdHJhbnNsYXRlOiBbMCwgMF0KICAgICAgfTsKICAgIH0sCiAgICBkcmF3ZWQ6IGZ1bmN0aW9uIGRyYXdlZChfcmVmNSwgX3JlZjYpIHsKICAgICAgdmFyIHBvaW50cyA9IF9yZWY1LnNoYXBlLnBvaW50czsKICAgICAgdmFyIGN0eCA9IF9yZWY2LmN0eCwKICAgICAgICBhcmVhID0gX3JlZjYuYXJlYTsKICAgICAgdmFyIGZpcnN0UG9pbnQgPSBwb2ludHNbMF07CiAgICAgIHZhciBsYXN0UG9pbnQgPSBwb2ludHMuc2xpY2UoLTEpWzBdOwogICAgICB2YXIgaCA9IGFyZWFbMV07CiAgICAgIGN0eC5saW5lVG8obGFzdFBvaW50WzBdLCBoKTsKICAgICAgY3R4LmxpbmVUbyhmaXJzdFBvaW50WzBdLCBoKTsKICAgICAgY3R4LmNsb3NlUGF0aCgpOwogICAgICBjdHguZmlsbCgpOwogICAgfSwKICAgIGFuaW1hdGlvbldhdmU6IGZ1bmN0aW9uIGFuaW1hdGlvbldhdmUoKSB7CiAgICAgIHZhciBfYXJndW1lbnRzID0gYXJndW1lbnRzLAogICAgICAgIF90aGlzID0gdGhpczsKICAgICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHsKICAgICAgICB2YXIgcmVwZWF0LCB3YXZlcywgcmVuZGVyZXIsIGFuaW1hdGlvbiwgdzsKICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHsKICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7CiAgICAgICAgICAgIGNhc2UgMDoKICAgICAgICAgICAgICByZXBlYXQgPSBfYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgX2FyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3VtZW50c1swXSA6IDE7CiAgICAgICAgICAgICAgd2F2ZXMgPSBfdGhpcy53YXZlcywgcmVuZGVyZXIgPSBfdGhpcy5yZW5kZXJlciwgYW5pbWF0aW9uID0gX3RoaXMuYW5pbWF0aW9uOwogICAgICAgICAgICAgIGlmICghYW5pbWF0aW9uKSB7CiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KCJyZXR1cm4iKTsKICAgICAgICAgICAgY2FzZSA0OgogICAgICAgICAgICAgIF90aGlzLmFuaW1hdGlvbiA9IHRydWU7CiAgICAgICAgICAgICAgdyA9IHJlbmRlcmVyLmFyZWFbMF07CiAgICAgICAgICAgICAgd2F2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZ3JhcGgpIHsKICAgICAgICAgICAgICAgIGdyYXBoLmF0dHIoJ3N0eWxlJywgewogICAgICAgICAgICAgICAgICB0cmFuc2xhdGU6IFswLCAwXQogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICBncmFwaC5hbmltYXRpb24oJ3N0eWxlJywgewogICAgICAgICAgICAgICAgICB0cmFuc2xhdGU6IFt3LCAwXQogICAgICAgICAgICAgICAgfSwgdHJ1ZSk7CiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDk7CiAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlcmVyLmxhdW5jaEFuaW1hdGlvbigpOwogICAgICAgICAgICBjYXNlIDk6CiAgICAgICAgICAgICAgX3RoaXMuYW5pbWF0aW9uID0gZmFsc2U7CiAgICAgICAgICAgICAgaWYgKHJlbmRlcmVyLmdyYXBocy5sZW5ndGgpIHsKICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMjsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KCJyZXR1cm4iKTsKICAgICAgICAgICAgY2FzZSAxMjoKICAgICAgICAgICAgICBfdGhpcy5hbmltYXRpb25XYXZlKHJlcGVhdCArIDEpOwogICAgICAgICAgICBjYXNlIDEzOgogICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7CiAgICAgICAgICB9CiAgICAgICAgfSwgX2NhbGxlZSk7CiAgICAgIH0pKSgpOwogICAgfQogIH0sCiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHsKICAgIHZhciBpbml0ID0gdGhpcy5pbml0OwogICAgaW5pdCgpOwogIH0sCiAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSgpIHsKICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7CiAgICByZW5kZXJlci5kZWxBbGxHcmFwaCgpOwogICAgdGhpcy53YXZlcyA9IFtdOwogIH0KfTs="},{"version":3,"mappings":";;;;;;;;;;;AA0CA;AAEA;AAEA;AAEA;AAEA;EACAA;EACAC;IACAC;IACAC;MAAA;IAAA;EACA;EACAC;IACA;IACA;MACAC;MAEAC;QACA;AACA;AACA;AACA;AACA;AACA;QACAF;QACA;AACA;AACA;AACA;AACA;AACA;QACAG;QACA;AACA;AACA;AACA;AACA;QACAC;QACA;AACA;AACA;AACA;AACA;QACAC;QACA;AACA;AACA;AACA;AACA;QACAC;QACA;AACA;AACA;AACA;AACA;AACA;QACAC;QACA;AACA;AACA;AACA;AACA;QACAC;MACA;MAEAC;MAEAC;MAEAC;MAEAC;MAEAC;MAEAC;IACA;EACA;EACAC;IACAC;MACA;MAEA;MAEA;MAEA;MAEA;IACA;IACAb;MACA;MAEA;MAEA;IACA;EACA;EACAc;IACAnB;MACA;QAAAY;MAEAA;MAEA;MAEAQ;IACA;EACA;EACAC;IACAC;MACA;QAAAtB;QAAAuB;MAEAC;MAEA;MAEAD;IACA;IACAC;MACA;MAEA;IACA;IACAD;MACA;QAAAE;QAAAC;MAEAC;MAEAF;MAEAC;MAEA;QAAAE;MAEAC;MAEAD;IACA;IACAD;MACA;QAAAvB;MAEA;IACA;IACAqB;MACA;MAEA;MAEA;MAEA;QAAA;MAAA;IACA;IACAC;MACA;QAAAxB;QAAAQ;MAEA;QACA;QAEA;MACA;MAEA;MAEA;IACA;IACAmB;MACA;QAAAC;QAAAC;QAAAC;MAEA;MACA;MAEA;QAAA;UACAlC;UACAmC;UACA5B;UACA6B;UACAF;QACA;MAAA;IACA;IACAF;MACA;QAAAlB;QAAAuB;MAEA;QAAA5B;QAAAL;MAEA;QAAAkC;QAAAC;MAEA;MAEA;MAEA;QACA;UACA;UAEA;UAEA;UAEA;QACA;QAEAC;UAAA;QAAA;QAEA;UAAAA;QAAA;MACA;IACA;IACAH;MAAA;QAAAI;QAAAC;MAAA;QAAAC;QAAAC;MACA;IACA;IACAX;MACA;QAAApB;MAEA;MAEA;QACAgC;QACAC;QACAC;QACAC;QACAC;QACAC;MACA;IACA;IACAhB;MAAA;MAAA;QAAAiB;MACA;MACA;MAEA;MAEAC;MACAA;MAEAA;MAEAA;IACA;IACAtB;MAAA;QAAAuB;MAAA;QAAA;QAAA;UAAA;YAAA;cAAAC;cACArC;cAAA,KAEAC;gBAAAqC;gBAAA;cAAA;cAAA;YAAA;cAEAF;cAEAf;cAEArB;gBACAuC;kBAAAN;gBAAA;gBAEAM;kBACAN;gBACA;cACA;cAAAK;cAAA,OAEAzC;YAAA;cAEAuC;cAAA,IAEAvC;gBAAAyC;gBAAA;cAAA;cAAA;YAAA;cAEAF;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA;IACA;EACA;EACAI;IACA;IAEAjC;EACA;EACAkC;IACA;IAEA5C;IAEA;EACA;AACA","names":["name","props","config","default","data","gradientId","defaultConfig","shape","waveNum","waveHeight","waveOpacity","colors","formatter","mergedConfig","renderer","svgBorderGradient","details","waves","animation","computed","radius","watch","setTimeout","methods","init","calcData","initRender","calcSvgBorderGradient","calcDetails","mergeConfig","animationWave","addWave","getWaveShapes","getWaveStyle","drawed","animationFrame","style","mergeOffset","w","h","points","x","y","ox","oy","gradientColor","gradientType","gradientParams","gradientWith","opacity","translate","area","ctx","_this","repeat","_context","graph","mounted","beforeDestroy"],"sourceRoot":"node_modules/@jiaminghi/data-view/lib/components/waterLevelPond/src","sources":["main.vue"],"sourcesContent":["<template>\n  <div class=\"dv-water-pond-level\">\n    <svg v-if=\"renderer\">\n      <defs>\n        <linearGradient :id=\"gradientId\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\n          <stop v-for=\"lc in svgBorderGradient\" :key=\"lc[0]\"\n            :offset=\"lc[0]\"\n            :stop-color=\"lc[1]\" />\n        </linearGradient>\n      </defs>\n\n      <text\n        v-if=\"renderer\"\n        :stroke=\"`url(#${gradientId})`\"\n        :fill=\"`url(#${gradientId})`\"\n        :x=\"renderer.area[0] / 2 + 8\"\n        :y=\"renderer.area[1] / 2 + 8\"\n      >\n        {{ details }}\n      </text>\n\n      <ellipse v-if=\"!shape || shape === 'round'\"\n        :cx=\"renderer.area[0] / 2 + 8\"\n        :cy=\"renderer.area[1] / 2 + 8\"\n        :rx=\"renderer.area[0] / 2 + 5\"\n        :ry=\"renderer.area[1] / 2 + 5\"\n        :stroke=\"`url(#${gradientId})`\" />\n\n      <rect v-else\n        x=\"2\" y=\"2\"\n        :rx=\"shape === 'roundRect' ? 10 : 0\"\n        :ry=\"shape === 'roundRect' ? 10 : 0\"\n        :width=\"renderer.area[0] + 12\"\n        :height=\"renderer.area[1] + 12\"\n        :stroke=\"`url(#${gradientId})`\" />\n    </svg>\n\n    <canvas ref=\"water-pond-level\" :style=\"`border-radius: ${radius};`\" />\n  </div>\n</template>\n\n<script>\nimport { uuid } from '../../../util/index'\n\nimport { deepMerge } from '@jiaminghi/charts/lib/util/index'\n\nimport { deepClone } from '@jiaminghi/c-render/lib/plugin/util'\n\nimport CRender from '@jiaminghi/c-render'\n\nexport default {\n  name: 'DvWaterLevelPond',\n  props: {\n    config: Object,\n    default: () => ({})\n  },\n  data () {\n    const id = uuid()\n    return {\n      gradientId: `water-level-pond-${id}`,\n\n      defaultConfig: {\n        /**\n         * @description Data\n         * @type {Array<Number>}\n         * @default data = []\n         * @example data = [60, 40]\n         */\n        data: [],\n        /**\n         * @description Shape of wanter level pond\n         * @type {String}\n         * @default shape = 'rect'\n         * @example shape = 'rect' | 'roundRect' | 'round'\n         */\n        shape: 'rect',\n        /**\n         * @description Water wave number\n         * @type {Number}\n         * @default waveNum = 3\n         */\n        waveNum: 3,\n        /**\n         * @description Water wave height (px)\n         * @type {Number}\n         * @default waveHeight = 40\n         */\n        waveHeight: 40,\n        /**\n         * @description Wave opacity\n         * @type {Number}\n         * @default waveOpacity = 0.4\n         */\n        waveOpacity: 0.4,\n        /**\n         * @description Colors (hex|rgb|rgba|color keywords)\n         * @type {Array<String>}\n         * @default colors = ['#00BAFF', '#3DE7C9']\n         * @example colors = ['#000', 'rgb(0, 0, 0)', 'rgba(0, 0, 0, 1)', 'red']\n         */\n        colors: ['#3DE7C9', '#00BAFF'],\n        /**\n         * @description Formatter\n         * @type {String}\n         * @default formatter = '{value}%'\n         */\n        formatter: '{value}%'\n      },\n\n      mergedConfig: {},\n\n      renderer: null,\n\n      svgBorderGradient: [],\n\n      details: '',\n\n      waves: [],\n\n      animation: false\n    }\n  },\n  computed: {\n    radius () {\n      const { shape } = this.mergedConfig\n\n      if (shape === 'round') return '50%'\n\n      if (shape === 'rect') return '0'\n\n      if (shape === 'roundRect') return '10px'\n\n      return '0'\n    },\n    shape () {\n      const { shape } = this.mergedConfig\n\n      if (!shape) return 'rect'\n\n      return shape\n    }\n  },\n  watch: {\n    config () {\n      const { calcData, renderer } = this\n\n      renderer.delAllGraph()\n\n      this.waves = []\n\n      setTimeout(calcData, 0)\n    }\n  },\n  methods: {\n    init () {\n      const { initRender, config, calcData } = this\n\n      initRender()\n\n      if (!config) return\n\n      calcData()\n    },\n    initRender () {\n      const { $refs } = this\n\n      this.renderer = new CRender($refs['water-pond-level'])\n    },\n    calcData () {\n      const { mergeConfig, calcSvgBorderGradient, calcDetails } = this\n\n      mergeConfig()\n\n      calcSvgBorderGradient()\n\n      calcDetails()\n\n      const { addWave, animationWave } = this\n\n      addWave()\n\n      animationWave()\n    },\n    mergeConfig () {\n      const { config, defaultConfig } = this\n\n      this.mergedConfig = deepMerge(deepClone(defaultConfig, true), config)\n    },\n    calcSvgBorderGradient () {\n      const { colors } = this.mergedConfig\n\n      const colorNum = colors.length\n\n      const colorOffsetGap = 100 / (colorNum - 1)\n\n      this.svgBorderGradient = colors.map((c, i) => [colorOffsetGap * i, c])\n    },\n    calcDetails () {\n      const { data, formatter } = this.mergedConfig\n\n      if (!data.length) {\n        this.details = ''\n\n        return\n      }\n\n      const maxValue = Math.max(...data)\n\n      this.details = formatter.replace('{value}', maxValue)\n    },\n    addWave () {\n      const { renderer, getWaveShapes, getWaveStyle, drawed } = this\n\n      const shapes = getWaveShapes()\n      const style = getWaveStyle()\n\n      this.waves = shapes.map(shape => renderer.add({\n        name: 'smoothline',\n        animationFrame: 300,\n        shape,\n        style,\n        drawed\n      }))\n    },\n    getWaveShapes () {\n      const { mergedConfig, renderer, mergeOffset } = this\n\n      const { waveNum, waveHeight, data } = mergedConfig\n\n      const [w, h] = renderer.area\n\n      const pointsNum = waveNum * 4 + 4\n\n      const pointXGap = w / waveNum / 2\n\n      return data.map(v => {\n        let points = new Array(pointsNum).fill(0).map((foo, j) => {\n          const x = w - pointXGap * j\n\n          const startY = (1 - v / 100) * h\n\n          const y = j % 2 === 0 ? startY : startY - waveHeight\n\n          return [x, y]\n        })\n\n        points = points.map(p => mergeOffset(p, [pointXGap * 2, 0]))\n\n        return { points }\n      })\n    },\n    mergeOffset ([x, y], [ox, oy]) {\n      return [x + ox, y + oy]\n    },\n    getWaveStyle () {\n      const { renderer, mergedConfig } = this\n\n      const h = renderer.area[1]\n\n      return {\n        gradientColor: mergedConfig.colors,\n        gradientType: 'linear',\n        gradientParams: [0, 0, 0, h],\n        gradientWith: 'fill',\n        opacity: mergedConfig.waveOpacity,\n        translate: [0, 0]\n      }\n    },\n    drawed ({ shape: { points } }, { ctx, area }) {\n      const firstPoint = points[0]\n      const lastPoint = points.slice(-1)[0]\n\n      const h = area[1]\n\n      ctx.lineTo(lastPoint[0], h)\n      ctx.lineTo(firstPoint[0], h)\n\n      ctx.closePath()\n\n      ctx.fill()\n    },\n    async animationWave (repeat = 1) {\n      const { waves, renderer, animation } = this\n\n      if (animation) return\n\n      this.animation = true\n\n      const w = renderer.area[0]\n\n      waves.forEach(graph => {\n        graph.attr('style', { translate: [0, 0] })\n\n        graph.animation('style', {\n          translate: [w, 0]\n        }, true)\n      })\n\n      await renderer.launchAnimation()\n\n      this.animation = false\n\n      if (!renderer.graphs.length) return\n\n      this.animationWave(repeat + 1)\n    }\n  },\n  mounted () {\n    const { init } = this\n\n    init()\n  },\n  beforeDestroy () {\n    const { renderer } = this\n\n    renderer.delAllGraph()\n\n    this.waves = []\n  }\n}\n</script>"]}]}